% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SQLDataFrame-methods.R
\docType{methods}
\name{SQLDataFrame-methods}
\alias{SQLDataFrame-methods}
\alias{head}
\alias{head,SQLDataFrame-method}
\alias{tail,SQLDataFrame-method}
\alias{tail}
\alias{dim,SQLDataFrame-method}
\alias{dim}
\alias{dimnames,SQLDataFrame-method}
\alias{dimnames}
\alias{length,SQLDataFrame-method}
\alias{length}
\alias{names,SQLDataFrame-method}
\alias{names}
\alias{[,SQLDataFrame,ANY,ANY,ANY-method}
\alias{[,SQLDataFrame,ANY-method}
\alias{[,SQLDataFrame,SQLDataFrame,ANY,ANY-method}
\alias{[,SQLDataFrame,SQLDataFrame-method}
\alias{[,SQLDataFrame,list,ANY,ANY-method}
\alias{[,SQLDataFrame,list-method}
\alias{[[,SQLDataFrame-method}
\alias{$,SQLDataFrame-method}
\alias{filter.SQLDataFrame}
\alias{filter}
\alias{filter,SQLDataFrame-method}
\alias{mutate.SQLDataFrame}
\alias{mutate}
\alias{mutate,SQLDataFrame-methods}
\title{SQLDataFrame methods}
\usage{
\S4method{head}{SQLDataFrame}(x, n = 6L)

\S4method{tail}{SQLDataFrame}(x, n = 6L)

\S4method{dim}{SQLDataFrame}(x)

\S4method{dimnames}{SQLDataFrame}(x)

\S4method{length}{SQLDataFrame}(x)

\S4method{names}{SQLDataFrame}(x)

\S4method{[}{SQLDataFrame,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\S4method{[}{SQLDataFrame,SQLDataFrame,ANY,ANY}(x, i, j, ...,
  drop = TRUE)

\S4method{[}{SQLDataFrame,list,ANY,ANY}(x, i, j, ..., drop = TRUE)

\S4method{[[}{SQLDataFrame}(x, i, j, ...)

\S4method{$}{SQLDataFrame}(x, name)

\method{filter}{SQLDataFrame}(.data, ...)

\method{mutate}{SQLDataFrame}(.data, ...)
}
\arguments{
\item{x}{An \code{SQLDataFrame} object.}

\item{n}{Number of rows.}

\item{i}{Row subscript. Could be numeric / character / logical
values, a named list of key values, and \code{SQLDataFrame},
\code{data.frame}, \code{tibble} objects.}

\item{j}{Column subscript.}

\item{...}{additional arguments to be passed.
\itemize{
\item{\code{filter()}: }{Logical predicates defined in terms of the
    variables in ‘.data’. Multiple conditions are combined with
    ‘&’. Only rows where the condition evaluates to ‘TRUE’ are
    kept. See \code{?dplyr::filter} for more details.}
\item{\code{mutate()}: }{Name-value pairs of expressions, each with
    length 1 or the same length as the number of rows in the group
    (if using ‘group_by()’) or in the entire input (if not using
    groups). The name of each argument will be the name of a new
    variable, and the value will be its corresponding value. Use a
    ‘NULL’ value in ‘mutate’ to drop a variable.  New variables
    overwrite existing variables of the same name.}}}

\item{drop}{Whether to drop with reduced dimension. Default is
TRUE.}

\item{name}{column name to be extracted by \code{$}.}

\item{.data}{A \code{SQLDataFrame} object.}
}
\value{
\code{head, tail}: An \code{SQLDataFrame} object with
    certain rows.

\code{dim}: interger vector

\code{dimnames}: A list of character vectors.

\code{length}: An integer

\code{names}: A character vector

A \code{SQLDataFrame} object or vector with realized column
    values (with single column subsetting and default
    \code{drop=TRUE}. )

\code{filter}: A \code{SQLDataFrame} object with subset
    rows of the input SQLDataFrame object matching conditions.

\code{mutate}: A SQLDataFrame object.
}
\description{
\code{head, tail}: Retrieve the first / last n rows of
    the \code{SQLDataFrame} object. See \code{?S4Vectors::head} for
    more details.

\code{dim, dimnames, length, names}: Retrieve the
    dimension, dimension names, number of columns and colnames of
    SQLDataFrame object.

\code{[i, j]} supports subsetting by \code{i} (for
    row) and \code{j} (for column) and respects ‘drop=FALSE’.

Use \code{filter()} to choose rows/cases where
    conditions are true.

\code{mutate()} adds new columns and preserves
    existing ones; It also preserves the number of rows of the
    input. New variables overwrite existing variables of the same
    name.
}
\examples{

##################
## basic methods
##################

dbname <- system.file("extdata/test.db", package = "SQLDataFrame")
obj <- SQLDataFrame(dbname = dbname, dbtable = "state", dbkey = "state")
dim(obj)
dimnames(obj)
length(obj)
names(obj)

obj1 <- SQLDataFrame(dbname = dbname, dbtable = "state",
                     dbkey = c("region", "population"))
###############
## subsetting
###############

obj[1]
obj["region"]
obj$region
obj[]
obj[,]
obj[NULL, ]
obj[, NULL]

## by numeric / logical / character vectors
obj[1:5, 2:3]
obj[c(TRUE, FALSE), c(TRUE, FALSE)]
obj[c("Alabama", "South Dakota"), ]
obj1[c("South\\b3615.0", "West\\b3559.0"), ]
### Remeber to add `.0` trailing for numeric values. If not sure,
### check `ROWNAMES()`.

## by SQLDataFrame
obj_sub <- obj[sample(10), ]
obj[obj_sub, ]

## by a named list of key column values (or equivalently data.frame /
## tibble)
obj[data.frame(state = c("Colorado", "Arizona")), ]
obj[tibble::tibble(state = c("Colorado", "Arizona")), ]
obj[list(state = c("Colorado", "Arizona")), ]
obj1[list(region = c("South", "West"),
          population = c("3615.0", "365.0")), ]
### remember to add the '.0' trailing for numeric values. If not sure,
### check `ROWNAMES()`.

###################
## filter & mutate 
###################

library(dplyr)
obj \%>\% filter(region == "West" & size == "medium")
obj1 \%>\% filter(region == "West" & population > 10000)

obj \%>\% mutate(p1 = population / 10)
obj \%>\% mutate(s1 = size)
}
