% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SQLDataFrame-methods.R
\name{filter.SQLDataFrame}
\alias{filter.SQLDataFrame}
\alias{filter}
\alias{filter,SQLDataFrame-methods}
\alias{mutate.SQLDataFrame}
\alias{mutate}
\alias{mutate,SQLDataFrame-methods}
\title{Return SQLDataFrame rows with matching conditions}
\usage{
\method{filter}{SQLDataFrame}(.data, ...)

\method{mutate}{SQLDataFrame}(.data, ...)
}
\arguments{
\item{.data}{A SQLDataFrame object.}

\item{...}{Logical predicates defined in terms of the variables in
‘.data’. Multiple conditions are combined with ‘&’. Only rows
where the condition evaluates to ‘TRUE’ are kept. See
\code{?dplyr::filter} for more details.}

\item{.data}{A SQLDataFrame object.}

\item{...}{Name-value pairs of expressions, each with length 1 or
the same length as the number of rows in the group (if using
‘group_by()’) or in the entire input (if not using groups). The
name of each argument will be the name of a new variable, and
the value will be its corresponding value. Use a ‘NULL’ value
in ‘mutate’ to drop a variable.  New variables overwrite
existing variables of the same name.}
}
\value{
A SQLDataFrame object with subset rows of the input
    SQLDataFrame object matching conditions.

A SQLDataFrame object.
}
\description{
Use ‘filter()’ to choose rows/cases where conditions
    are true.

\code{mutate()} adds new columns and preserves
    existing ones; It also preserves the number of rows of the
    input. New variables overwrite existing variables of the same
    name.
}
\examples{
dbfile <- system.file("extdata/test.db", package = "SQLDataFrame")
obj <- SQLDataFrame(dbname = dbfile, dbtable = "state", dbkey = "state")
obj1 <- obj \%>\% filter(region == "West" & size == "medium")
obj1
dbfile <- system.file("extdata/test.db", package = "SQLDataFrame")
obj <- SQLDataFrame(dbname = dbfile, dbtable = "state", dbkey = "state")
obj \%>\% mutate(p1 = population / 10)
obj \%>\% mutate(s1 = size)

}
