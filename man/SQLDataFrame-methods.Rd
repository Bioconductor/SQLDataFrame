% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SQLDataFrame-methods.R
\name{SQLDataFrame-methods}
\alias{SQLDataFrame-methods}
\alias{head}
\alias{head,SQLDataFrame-method}
\alias{tail,SQLDataFrame-method}
\alias{tail}
\alias{dim,SQLDataFrame-method}
\alias{dim}
\alias{dimnames,SQLDataFrame-method}
\alias{dimnames}
\alias{length,SQLDataFrame-method}
\alias{length}
\alias{names,SQLDataFrame-method}
\alias{names}
\alias{[,SQLDataFrame,ANY,ANY,ANY-method}
\alias{[[,SQLDataFrame-method}
\alias{$,SQLDataFrame-method}
\alias{select.SQLDataFrame}
\alias{select}
\alias{select,SQLDataFrame-methods}
\alias{filter.SQLDataFrame}
\alias{filter}
\alias{filter,SQLDataFrame-method}
\alias{mutate.SQLDataFrame}
\alias{mutate}
\alias{mutate,SQLDataFrame-methods}
\alias{connSQLDataFrame}
\title{SQLDataFrame methods}
\usage{
\S4method{head}{SQLDataFrame}(x, n = 6L)

\S4method{tail}{SQLDataFrame}(x, n = 6L)

\S4method{dim}{SQLDataFrame}(x)

\S4method{dimnames}{SQLDataFrame}(x)

\S4method{length}{SQLDataFrame}(x)

\S4method{names}{SQLDataFrame}(x)

\S4method{[}{SQLDataFrame,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\S4method{[[}{SQLDataFrame}(x, i, j, ...)

\S4method{$}{SQLDataFrame}(x, name)

\method{select}{SQLDataFrame}(.data, ...)

\method{filter}{SQLDataFrame}(.data, ...)

\method{mutate}{SQLDataFrame}(.data, ...)

connSQLDataFrame(x)
}
\arguments{
\item{x}{An \code{SQLDataFrame} object.}

\item{n}{Number of rows.}

\item{i}{Row subscript. Could be numeric / logical values, a named
list of key values, and \code{SQLDataFrame}, \code{data.frame},
\code{tibble} objects.}

\item{j}{Column subscript.}

\item{...}{additional arguments to be passed.  \itemize{ \item
\code{select()}: One or more unquoted expressions separated by
commas. You can treat variable names like they are positions,
so you can use expressions like ‘x:y’ to select ranges of
variables. Positive values select variables; negative values
drop variables. See \code{?dplyr::select} for more details.
\item \code{filter()}: Logical predicates defined in terms of
the variables in ‘.data’. Multiple conditions are combined with
‘&’. Only rows where the condition evaluates to ‘TRUE’ are
kept. See \code{?dplyr::filter} for more details.  \item
\code{mutate()}: Name-value pairs of expressions, each with
length 1 or the same length as the number of rows in the group
(if using ‘group_by()’) or in the entire input (if not using
groups). The name of each argument will be the name of a new
variable, and the value will be its corresponding value. Use a
‘NULL’ value in ‘mutate’ to drop a variable.  New variables
overwrite existing variables of the same name.  }}

\item{drop}{Whether to drop with reduced dimension. Default is
TRUE.}

\item{name}{column name to be extracted by \code{$}.}

\item{.data}{A \code{SQLDataFrame} object.}
}
\value{
\code{head, tail}: An \code{SQLDataFrame} object with
    certain rows.

\code{dim}: interger vector

\code{dimnames}: A list of character vectors.

\code{length}: An integer

\code{names}: A character vector

\code{[i, j]}: A \code{SQLDataFrame} object or vector with
    realized column values (with single column subsetting and
    default \code{drop=TRUE}. )

\code{select}: always returns a SQLDataFrame object no
    matter how may columns are selected. If only key column(s)
    is(are) selected, it will return a \code{SQLDataFrame} object
    with 0 col (only key columns are shown).

\code{filter}: A \code{SQLDataFrame} object with subset
    rows of the input SQLDataFrame object matching conditions.

\code{mutate}: A SQLDataFrame object.
}
\description{
\code{head, tail}: Retrieve the first / last n rows of
    the \code{SQLDataFrame} object. See \code{?S4Vectors::head} for
    more details.

\code{dim, dimnames, length, names}: Retrieve the
    dimension, dimension names, number of columns and colnames of
    SQLDataFrame object.

\code{[i, j]} supports subsetting by \code{i} (for
    row) and \code{j} (for column) and respects ‘drop=FALSE’.

Use \code{select()} function to select certain
    columns.

Use \code{filter()} to choose rows/cases where
    conditions are true. Note that after filtering, the original
    order of data will be dropped and data will be reordered by key
    columns.

\code{mutate()} adds new columns and preserves
    existing ones; It also preserves the number of rows of the
    input. New variables overwrite existing variables of the same
    name.

\code{connSQLDataFrame} returns the connection of a
    SQLDataFrame object.
}
\details{
Please note that \code{filter()} will reset the
    \code{ridx} slot of the returned SQLDataFrame, so that any
    arbitrary orders (or duplicate rows) of the input SQLDataFrame
    will not be preserved. \code{select()} and \code{mutate()}
    could preserve the original orders or duplicate rows.
}
\examples{

##################
## basic methods
##################

test.db <- system.file("extdata/test.db", package = "SQLDataFrame")
conn <- DBI::dbConnect(DBI::dbDriver("SQLite"), dbname = test.db)
obj <- SQLDataFrame(conn = conn, dbtable = "state", dbkey = "state")
dim(obj)
dimnames(obj)
length(obj)
names(obj)

obj1 <- SQLDataFrame(conn = conn, dbtable = "state",
                     dbkey = c("region", "population"))
###############
## subsetting
###############

obj[1]
obj["region"]
obj$region
obj[]
obj[,]
obj[NULL, ]
obj[, NULL]

## by numeric / logical vectors
obj[1:5, 2:3]
obj[c(TRUE, FALSE), c(TRUE, FALSE)]

## Subsetting with key columns

obj["state"] ## list style subsetting, return a SQLDataFrame object with col = 0.
obj[c("state", "division")]  ## list style subsetting, return a SQLDataFrame object with col = 1.
obj[, "state"] ## realize specific key column value.
obj[, c("state", "division")] ## col = 1, but do not realize.


###################
## select, filter, mutate
###################
library(dplyr)
obj \%>\% select(division)  ## equivalent to obj["division"], or obj[, "division", drop = FALSE]
obj \%>\% select(region:size)

obj \%>\% filter(region == "West" & size == "medium")
obj1 \%>\% filter(region == "West" & population > 10000)

obj \%>\% mutate(p1 = population / 10)
obj \%>\% mutate(s1 = size)

obj \%>\% select(region, size, population) \%>\% 
    filter(population > 10000) \%>\% 
    mutate(pK = population/1000)
obj1 \%>\% select(region, size, population) \%>\% 
    filter(population > 10000) \%>\% 
    mutate(pK = population/1000)  

###################
## connection info
###################

connSQLDataFrame(obj)
}
