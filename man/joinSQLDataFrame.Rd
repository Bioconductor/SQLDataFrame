% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bk.joinSQLDataFrame.R, R/joinSQLDataFrame.R
\name{left_join}
\alias{left_join}
\alias{left_join.SQLDataFrame}
\alias{left_join,SQLDataFrame-method}
\alias{inner_join}
\alias{inner_join.SQLDataFrame}
\alias{inner_join,SQLDataFrame-method}
\alias{semi_join}
\alias{semi_join.SQLDataFrame}
\alias{semi_join,SQLDataFrame-method}
\alias{anti_join}
\alias{anti_join.SQLDataFrame}
\alias{anti_join,SQLDataFrame-method}
\title{join \code{SQLDataFrame} together}
\usage{
\method{left_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{inner_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{semi_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{anti_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{left_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{inner_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{semi_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)

\method{anti_join}{SQLDataFrame}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), localConn, ...)
}
\arguments{
\item{x}{\code{SQLDataFrame} objects to join.}

\item{y}{\code{SQLDataFrame} objects to join.}

\item{by}{A character vector of variables to join by.  If ‘NULL’,
the default, ‘*_join()’ will do a natural join, using all
variables with common names across the two tables. See
\code{?dplyr::join} for details.}

\item{copy}{see \code{?dplyr::join} for details.}

\item{suffix}{A character vector of length 2 specify the suffixes
to be added if there are non-joined duplicate variables in ‘x’
and ‘y’. Default values are ".x" and ".y".See
\code{?dplyr::join} for details.}

\item{...}{additional arguments to be passed.}

\item{x}{\code{SQLDataFrame} objects to join.}

\item{y}{\code{SQLDataFrame} objects to join.}

\item{by}{A character vector of variables to join by.  If ‘NULL’,
the default, ‘*_join()’ will do a natural join, using all
variables with common names across the two tables. See
\code{?dplyr::join} for details.}

\item{copy}{see \code{?dplyr::join} for details.}

\item{suffix}{A character vector of length 2 specify the suffixes
to be added if there are non-joined duplicate variables in ‘x’
and ‘y’. Default values are ".x" and ".y".See
\code{?dplyr::join} for details.}

\item{...}{additional arguments to be passed.}
}
\value{
A \code{SQLDataFrame} object.

A \code{SQLDataFrame} object.
}
\description{
*_join functions for \code{SQLDataFrame} objects. Will
    preserve the duplicate rows for the input argument `x`.

*_join functions for \code{SQLDataFrame} objects. Will
    preserve the duplicate rows for the input argument `x`.
}
\examples{
test.db1 <- system.file("extdata/test.db", package = "SQLDataFrame")
test.db2 <- system.file("extdata/test1.db", package = "SQLDataFrame")
con1 <- DBI::dbConnect(DBI::dbDriver("SQLite"), dbname = test.db1)
con2 <- DBI::dbConnect(DBI::dbDriver("SQLite"), dbname = test.db2)
obj1 <- SQLDataFrame(conn = con1,
                     dbtable = "state",
                     dbkey = c("region", "population"))
obj2 <- SQLDataFrame(conn = con2,
                     dbtable = "state1",
                     dbkey = c("region", "population"))

obj1_sub <- obj1[1:10, 1:2]
obj2_sub <- obj2[8:15, 2:3]

left_join(obj1_sub, obj2_sub)
inner_join(obj1_sub, obj2_sub)
semi_join(obj1_sub, obj2_sub)
anti_join(obj1_sub, obj2_sub)
test.db1 <- system.file("extdata/test.db", package = "SQLDataFrame")
test.db2 <- system.file("extdata/test1.db", package = "SQLDataFrame")
con1 <- DBI::dbConnect(DBI::dbDriver("SQLite"), dbname = test.db1)
con2 <- DBI::dbConnect(DBI::dbDriver("SQLite"), dbname = test.db2)
obj1 <- SQLDataFrame(conn = con1,
                     dbtable = "state",
                     dbkey = c("region", "population"))
obj2 <- SQLDataFrame(conn = con2,
                     dbtable = "state1",
                     dbkey = c("region", "population"))

obj1_sub <- obj1[1:10, 1:2]
obj2_sub <- obj2[8:15, 2:3]

left_join(obj1_sub, obj2_sub)
inner_join(obj1_sub, obj2_sub)
semi_join(obj1_sub, obj2_sub)
anti_join(obj1_sub, obj2_sub)
}
