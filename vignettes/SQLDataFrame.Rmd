---
title: "SQLDataFrame: Representation of database table in DataFrame metaphor"
author:
- name: Qian Liu
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
- name: Martin Morgan
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
date: "last compiled: `r Sys.Date()`"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
package: SQLDataFrame
vignette: >
  %\VignetteIndexEntry{SQLDataFrame: Representation of database table in DataFrame metaphor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
date: "last edit: 11/30/2018"

# Introduction


Theoretically, users could choose to use different database backend
when doing the `SQLDataFrame` constructor. Five commonly used
backends are:

- _RMySQL_: connects to MySQL and MariaDB
- _RPostgreSQL_: connects to Postgres and Redshift.
- **RSQLite**: embeds a SQLite database. (now used as default)
- _odbc_ connects to many commercial databases via the open database
  connectivity protocol.
- _bigrquery_ connects to Googleâ€™s BigQuery.

[dbplyr]: https://cran.r-project.org/web/packages/dbplyr/index.html

# Installation

1. Download the package. 

```{r getPackage, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("SQLDataFrame")
```
The development version is also available to download from Github. 
```{r getDevel, eval=FALSE}
BiocManager::install("Liubuntu/SQLDataFrame")
```

2. Load the package into R session.
```{r Load, message=FALSE}
library(SQLDataFrame)
```

# SQLDataFrame
## SQLDataFrame constructor
To construct a `SQLDataFrame` object, 3 arguments are needed:
`dbname`, `dbtable` and `dbkey`. The `dbname` is the file path to the
database that is saved on-disk. `dbtable` argument specifies the
database table name that is going to be represented in `SQLDataFrame`
object. If only one table is available in the specified database name,
this argument could be left blank. The `dbkey` argument is used to
specify the column name in the table which could uniquely identify all
the data observations (rows).  

Note that after reading the database table into `SQLDataFrame`, the
key columns will be kept as fixed columns showing on the left hand
side, with `|` separating key column(s) with the other columns. The
`ncol`, `colnames`, and corresponding column subsetting will only
corresponds to the non-key-columns.


```{r constructor}
test.db <- system.file("inst/extdata/test.db", package = "SQLDataFrame")
obj <- SQLDataFrame(
    dbname = test.db, dbtable = "colData", dbkey = "sampleID")
obj
dim(obj)
colnames(obj)
```

## SQLDataFrame methods
### Slot accessors

To make the `SQLDataFrame` object as light and compact as possible,
there are only 5 slots contained in the object. Metadata information
could be returned through these 5 slots using slot accessors or other
utility functions.

```{r}
slotNames(obj)
dbname(obj)
dbtable(obj)
dbkey(obj)
colnames(obj)
```

The `tblData` slot saves the `dbplyr::tbl_dbi` version of the database
table, which is a light-weight representation of the database table in
_R_. The `dbnrow` slot saves the row information for the original
database table. 

When subsetting `SQLDataFrame` objects using `[`,
these 2 slots remains unchanged, but the `nrow()`, `ncol()`,
`colnames()` and `show()` method will reflect the data subsetting.

```{r}
obj@tblData
obj@dbnrows
```

Besides, many useful common methods are defined on `SQLDataFrame`
object to make it a more DataFrame-like data structure. e.g., we can
use `dimnames()` to return the row/colnames of the data. It returns an
unnamed list, with the first element being rownames which is always
`NULL`, and 2nd element being colnames (could also use `colnames()`
method). `dim()` method is defined to return the dimension of the
database table, which enables the `nrow()/ncol()` to extract a
specific dimension. `length()` method is also defined which works same
as `ncol()`.   
Note that the `rownames(SQLDataFrame)` would always be `NULL` as
rownames are not supported in `SQLDataFrame`.

```{r methods}
dim(obj)
dimnames(obj)
length(obj)
```

### `[[` subsetting
`[[,SQLDataFrame` Behaves similarly to `[[,DataFrame` and returns a
realized vector of values from a single column. `$,SQLDataFrame` is
also defined to conveniently extract column values.

```{r}
obj[[1]]
obj[[2]]
obj[["Ages"]]
obj$Ages
```

We can also get the key column values using character extraction. 
```{r}
obj[["sampleID"]]
```

### `[` subsetting

`SQLDataFrame` instances can be subsetted in a similar way of
`DataFrame` following the usual _R_ conventions, with numeric,
character or logical vectors; logical vectors are recycled to the
appropriate length. 

**NOTE**, use `drop=FALSE` explicitly for single
column subsetting if you want a `SQLDataFrame` object, otherwise, the
default `drop=TRUE` would always return a realized value for that
column.

```{r, subsetting}
obj[1:3, 1:2]
obj[c(TRUE, FALSE), c(TRUE, FALSE), drop=FALSE]
obj[1:3, "Ages", drop=FALSE]
obj[, "Ages"]  ## realized column value
```

The `ROWNAMES,SQLDataFrame` method is defined to return the key column
name (only works for `SQLDataFrame` object with a single key column),
so that the row subsetting with character vector works for the
**single-key-SQLDataFrame** objects.

```{r}
ROWNAMES(obj)
obj[c("a", "c", "d", "e"), ]
```

List style subsetting is also allowed to extract certain columns from
the `SQLDataFrame` object which returns `SQLDataFrame` by default.  

```{r}
obj[1]
obj["Ages"]
```

### Numeric calculation / Data manipulation (todo)

Numeric calculations could be evaluated on `SQLDataFrame` objects.

```{r, numeric, eval=FALSE}
sum(obj$Ages)
max(obj$Ages)
```

# SessionInfo()

```{r}
sessionInfo()
```


