---
title: "SQLDataFrame: Lazy representation of database table in DataFrame metaphor"
author:
- name: Qian Liu
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
- name: Martin Morgan
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
date: "last compiled: `r Sys.Date()`"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
package: SQLDataFrame
vignette: >
  %\VignetteIndexEntry{SQLDataFrame: Lazy representation of database table in DataFrame metaphor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
date: "last edit: 3/29/2018"

# Introduction

Theoretically, users could choose to use different database backend
when doing the `SQLDataFrame` constructor. Five commonly used
backends are:

- _RMySQL_: connects to MySQL and MariaDB
- _RPostgreSQL_: connects to Postgres and Redshift.
- **RSQLite**: embeds a SQLite database. (now used as default)
- _odbc_ connects to many commercial databases via the open database
  connectivity protocol.
- _bigrquery_ connects to Googleâ€™s BigQuery.

[dbplyr]: https://cran.r-project.org/web/packages/dbplyr/index.html

# Installation

1. Download the package. 

```{r getPackage, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("SQLDataFrame")
```
The development version is also available to download from Github. 
```{r getDevel, eval=FALSE}
BiocManager::install("Liubuntu/SQLDataFrame")
```
2. Load the package into R session.
```{r Load, message=FALSE}
library(SQLDataFrame)
```

# SQLDataFrame
## SQLDataFrame constructor
To construct a `SQLDataFrame` object, 3 arguments are needed:
`dbname`, `dbtable` and `dbkey`. The `dbname` is the file path to the
database that is on-disk or remote. `dbtable` argument specifies the
database table name that is going to be represented as `SQLDataFrame`
object. If only one table is available in the specified database name,
this argument could be left blank. The `dbkey` argument is used to
specify the column name in the table which could uniquely identify all
the data observations (rows).  

Note that after reading the database table into `SQLDataFrame`, the
key columns will be kept as fixed columns showing on the left hand
side, with `|` separating key column(s) with the other columns. The
`ncol`, `colnames`, and corresponding column subsetting will only
apply to the non-key-columns.


```{r constructor}
test.db <- system.file("inst/extdata/test.db", package = "SQLDataFrame")
obj <- SQLDataFrame(
    dbname = test.db, dbtable = "colData", dbkey = "sampleID")
obj
dim(obj)
colnames(obj)
```

## makeSQLDataFrame

We could also construct a `SQLDataFrame` object directly from a file
name. The `makeSQLDataFrame` function takes input of character value
of file name for common text files (.csv, .txt, etc.), write into
database tables, and open as `SQLDataFrame` object. Users could
provide values for the `dbname` and `dbtable` argument. If NULL,
default value for `dbname` would be a temporary database file, and
`dbtable` would be the `basename(filename)` without extension.

**NOTE** that the input file must have one or multiple columns that
could uniquely identify each observation (row) to be used the
`dbkey()` for `SQLDataFrame`. Also the file must be rectangular, i.e.,
rownames are not accepted. But users could save rownames as a separate
column. 

```{r}
mtc <- tibble::rownames_to_column(mtcars)
filename <- file.path(tempdir(), "mtc.csv")
write.csv(mtc, file= filename, row.names = FALSE)
aa <- makeSQLDataFrame(filename, dbkey = "rowname", sep = ",",
                       overwrite = TRUE)
aa
dbname(aa)
dbtable(aa)
```

## saveSQLDataFrame

With all the methods (`[` subsetting, `rbind`, `*_join`, etc.,)
provided in the next section, the `SQLDataFrame` always work like a
lazy representation until users explicitly call the `saveSQLDataFrame`
function for realization. `saveSQLDataFrame` write the lazy tbl
carried in `@tblData` into an on-disk database table, and reopen the
`SQLDataFrame` object from the new path.

It's also recommended that users call `saveSQLDataFrame` frequently to
avoid too many lazy layers which slows down the data processing. 

```{r}
dbname <- system.file("extdata/test.db", package = "SQLDataFrame")
ss <- SQLDataFrame(dbname = dbname, dbtable = "state", dbkey = "state")
## ss1 <- ss[1:10, 2:3]
## ss1
dbname(ss)
dbtable(ss)
ss1 <- saveSQLDataFrame(ss, dbname = tempfile(fileext = ".db"),
                        dbtable = "ss_copy")
dbname(ss1)
dbtable(ss1)
```

## SQLDataFrame methods
### Slot accessors & basic methods

To make the `SQLDataFrame` object as light and compact as possible,
there are only 5 slots contained in the object: `tblData`, `dbkey`,
`dbnrows`, `dbconcatKey`, `indexes`. Metadata information could be
returned through these 5 slots using slot accessors or other utility
functions.  
```{r}
slotNames(obj)
dbname(obj)
dbtable(obj)
dbkey(obj)
dbconcatKey(obj)
```

The `tblData` slot saves the `dbplyr::tbl_dbi` version of the database
table, which is a light-weight representation of the database table in
_R_. The `dbnrows` slot saves the number of rows corresponding to the
`obj@tblData`, and `dbconcatKey` saves the realized (concatenated) key
column values corresponding to the `obj@tblData`.  

```{r}
obj@tblData
obj@dbnrows
obj@dbconcatKey
```

Besides, many useful common methods are defined on `SQLDataFrame`
object to make it a more DataFrame-like data structure. e.g., we can
use `dimnames()` to return the row/colnames of the data. It returns an
unnamed list, with the first element being rownames which is always
`NULL`, and 2nd element being colnames (could also use `colnames()`
method). `dim()` method is defined to return the dimension of the
database table, which enables the `nrow()/ncol()` to extract a
specific dimension. `length()` method is also defined which works same
as `ncol()`.  
Note that the `rownames(SQLDataFrame)` would always be `NULL` as
rownames are not supported in `SQLDataFrame`. However, `ROWNAMES(obj)`
was implemented for the `[` subsetting with characters. 
 
```{r methods}
dim(obj)
dimnames(obj)
length(obj)
ROWNAMES(obj)
```

**NOTE** that the `dbtable()` accessor only works for a `SQLDataFrame`
object that the lazy tbl carried in `@tblData` slot corresponds to a
single database. If the `SQLDataFrame` was generated from `rbind`,
`union` or `*_join`, call `saveSQLDataFrame()` to save the lazy tbl to
disk so that `dbtable()` will be activated.

```{r}
dbtable(obj)
aa <- rbind(obj[1:5, ], obj[6:10, ])
aa
dbtable(aa)  ## message
bb <- saveSQLDataFrame(aa, dbname = tempfile(fileext=".db"),
                       dbtable = "aa", overwrite = TRUE)
dbtable(bb)
dbname(bb)
```

### `[[` subsetting
`[[,SQLDataFrame` Behaves similarly to `[[,DataFrame` and returns a
realized vector of values from a single column. `$,SQLDataFrame` is
also defined to conveniently extract column values.

```{r}
obj[[1]]
obj[[2]]
obj[["Ages"]]
obj$Ages
```

We can also get the key column values using character extraction. 
```{r}
obj[["sampleID"]]
```

### `[` subsetting

`SQLDataFrame` instances can be subsetted in a similar way of
`DataFrame` following the usual _R_ conventions, with numeric,
character or logical vectors; logical vectors are recycled to the
appropriate length. 

**NOTE**, use `drop=FALSE` explicitly for single column subsetting if
you want to return a `SQLDataFrame` object, otherwise, the default
`drop=TRUE` would always return a realized value for that column.

```{r, subsetting}
obj[1:3, 1:2]
obj[c(TRUE, FALSE), c(TRUE, FALSE), drop=FALSE]
obj[1:3, "Ages", drop=FALSE]
obj[, "Ages"]  ## realized column value
```

When subsetting `SQLDataFrame` objects using `[`, the slots of
`@tblData`, `@dbnrows`, and `@dbconcatKey` remain
unchanged. `@indexes` was updated to reflect the data subsetting, and
so does the methods of `nrow()`, `ncol()`, `colnames()` and `show()`.  

```{r}
obj1 <- obj[1:3, 1, drop = FALSE]
identical(obj@tblData, obj1@tblData)
identical(obj@dbnrows, obj1@dbnrows)
identical(obj@dbconcatKey, obj1@dbconcatKey)
obj1@indexes
colnames(obj1)
obj1
```

The `ROWNAMES,SQLDataFrame` method is defined to return the
(concatenated if multiple) key column name(s), so that the row
subsetting with character vector works for the `SQLDataFrame` objects.

```{r}
ROWNAMES(obj)
obj[c("a", "c", "d", "e"), ]
```

```{r}
obj1 <- SQLDataFrame(dbname = test.db, dbtable = "state",
                     dbkey = c("region", "population"))
ROWNAMES(obj1)
obj1[c("South\b3615.0", "West\b365.0"), ]
```

List style subsetting is also allowed to extract certain columns from
the `SQLDataFrame` object which returns `SQLDataFrame` by default.  

```{r}
obj[1]
obj["Ages"]
```

### union & rbind

To be consistent with `DataFrame`, `union` method 



### *_join methods

The `*_join` family methods was implemented for `SQLDataFrame`
objects. 

```{r}
ss <- SQLDataFrame(dbname = "inst/extdata/test.db",
                    dbtable = "state",
                    dbkey = c("region", "population"))
ss1 <- ss[1:10, 1, drop = FALSE]
ss2 <- ss[5:15, 2, drop=FALSE]

ss3 <- ss[8:15, 3, drop=FALSE]
ss4 <- ss[6:15, 3, drop = FALSE]

```



### Numeric calculation / Data manipulation (todo)

Numeric calculations could be evaluated on `SQLDataFrame` objects.

```{r, numeric, eval=FALSE}
sum(obj$Ages)
max(obj$Ages)
```

# SessionInfo()

```{r}
sessionInfo()
```


